name: Create vCluster
on:
  workflow_dispatch:
    inputs:
      cluster_name:
        description: Name for the cluster
        required: true
      namespace_name:
        description: Name for the namespace
        required: true
      host_name:
        description: Name of the host cluster to set the host context
        required: true
      kubernetes_version:
        description: Kubernetes version to use in vCluster (e.g. 1.31, 1.32)
        required: true
        default: "1.32"
      cpu:
        description: CPU limit for vCluster in millicores (e.g. 500)
        required: true
        default: 500
      memory:
        description: Memory limit for vCluster in Mi (e.g. 512)
        required: true
        default: 512
      storage:
        description: Persistent storage size in Gi (e.g. 10)
        required: true
        default: 10
      workflow_id:
        description: Temporal Workflow ID (optional)
        required: true
      signal_name:
        description: Temporal Signal Name (required if workflow_id is set)
        required: true
      signal_payload:
        description: Payload for the Temporal Signal (optional)
        required: true
jobs:
  deploy-vcluster:
    environment: aks
    runs-on: [self-hosted, Linux]
    defaults:
      run:
        shell: bash
    env:
      NAMESPACE_NAME: ${{ github.event.inputs.namespace_name }}
      CLUSTER_NAME: ${{ github.event.inputs.cluster_name }}
      KUBERNETES_VERSION: ${{ github.event.inputs.kubernetes_version }}
      CPU: ${{ github.event.inputs.cpu }}
      MEMORY: ${{ github.event.inputs.memory }}
      STORAGE: ${{ github.event.inputs.storage }}
      KUBECONFIG_FILE: "/home/minha/admin/config_files/${{ github.event.inputs.host_name }}.config"
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify kubeconfig file exists
        run: |
          if [ ! -f "$KUBECONFIG_FILE" ]; then
            echo "ERROR: Kubeconfig file not found at: $KUBECONFIG_FILE"
            echo "Available files in admin/config_files/:"
            ls -la admin/config_files/ || echo "Directory does not exist"
            exit 1
          fi
          echo "Kubeconfig file found: $KUBECONFIG_FILE"
      
      - name: Set KUBECONFIG for target cluster
        run: |
          echo "Setting KUBECONFIG to: $KUBECONFIG_FILE"
          export KUBECONFIG="$KUBECONFIG_FILE"

          # Verify cluster connection
          echo "Verifying cluster connection..."
          kubectl cluster-info --request-timeout=10s

          echo "Current context:"
          kubectl config current-context

          echo "Available nodes:"
          kubectl get nodes --request-timeout=10s

          # Make KUBECONFIG available for subsequent steps
          echo "KUBECONFIG=$KUBECONFIG_FILE" >> $GITHUB_ENV

      - name: Create namespace if it doesn't exist
        run: |
          echo "Checking if namespace '$NAMESPACE_NAME' exists..."
          if ! kubectl get namespace "$NAMESPACE_NAME" >/dev/null 2>&1; then
            echo "Creating namespace: $NAMESPACE_NAME"
            kubectl create namespace "$NAMESPACE_NAME"
          else
            echo "Namespace '$NAMESPACE_NAME' already exists"
          fi

      - name: Create vCluster with resource limits
        run: |
          helm upgrade --install "$CLUSTER_NAME" \
          --create-namespace \
          --set cluster_name="$CLUSTER_NAME" \
          --set namespace_name="$NAMESPACE_NAME" \
          --set kubernetes_version="$KUBERNETES_VERSION" \
          --set cluster_cpu="$CPU" \
          --set cluster_ram="$MEMORY" \
          --set cluster_storage="$STORAGE" \
          ./armada-vcluster

      - name: Wait for pods to be created and ready
        run: |
          echo "Waiting for pods to appear in namespace: $NAMESPACE_NAME..."
          sleep 40
          kubectl wait --for=condition=Ready pods --all -n "$NAMESPACE_NAME" --timeout=120s

      - name: Signal Temporal Workflow
        if: success()
        run: |
          # Build JSON body
          body=$(jq -n \
            --arg workflowId "${{ github.event.inputs.workflow_id }}" \
            --arg signalName "${{ github.event.inputs.signal_name }}" \
            --arg signalInput "${{ github.event.inputs.signal_payload }}" \
            '{workflowId: $workflowId, signalName: $signalName, signalInput: $signalInput}')

          # Send POST request
          curl -X POST http://localhost:8080/trigger-signal \
            -H "Content-Type: application/json" \
            -d "$body"